"""
Security Scanner Module
Detects security vulnerabilities and misconfigurations
"""

import subprocess
import os
import re
import platform
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from enum import Enum


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class Vulnerability:
    """Represents a detected vulnerability"""
    id: str
    name: str
    description: str
    severity: VulnerabilitySeverity
    category: str
    affected_component: str
    remediation: str
    cve_id: Optional[str]  # CVE identifier if applicable
    is_patchable: bool
    requires_restart: bool


class SecurityScanner:
    """
    Scans system for security vulnerabilities and misconfigurations.
    Cross-platform: Works on Linux and Windows.
    """

    def __init__(self):
        self.platform = platform.system().lower()
        self.detected_vulnerabilities: List[Vulnerability] = []

    def scan_system(self) -> List[Vulnerability]:
        """
        Perform comprehensive security scan.
        Returns list of detected vulnerabilities.
        """
        vulnerabilities = []

        if self.platform == "linux":
            vulnerabilities.extend(self._scan_linux())
        elif self.platform == "windows":
            vulnerabilities.extend(self._scan_windows())

        # Cross-platform checks
        vulnerabilities.extend(self._scan_network())
        vulnerabilities.extend(self._scan_services())

        self.detected_vulnerabilities = vulnerabilities
        return vulnerabilities

    def _scan_linux(self) -> List[Vulnerability]:
        """Linux-specific security scan"""
        vulnerabilities = []

        # Check for outdated packages
        vulnerabilities.extend(self._check_package_updates())

        # Check SSH configuration
        vulnerabilities.extend(self._check_ssh_config())

        # Check firewall status
        vulnerabilities.extend(self._check_firewall_linux())

        # Check for world-writable files
        vulnerabilities.extend(self._check_world_writable())

        # Check for SUID binaries
        vulnerabilities.extend(self._check_suid_binaries())

        # Check password policies
        vulnerabilities.extend(self._check_password_policies())

        # Check for unattended upgrades
        vulnerabilities.extend(self._check_auto_updates())

        return vulnerabilities

    def _scan_windows(self) -> List[Vulnerability]:
        """Windows-specific security scan"""
        vulnerabilities = []

        # Check Windows Defender status
        vulnerabilities.extend(self._check_defender_status())

        # Check Windows Update status
        vulnerabilities.extend(self._check_windows_update())

        # Check firewall status
        vulnerabilities.extend(self._check_firewall_windows())

        # Check UAC status
        vulnerabilities.extend(self._check_uac())

        # Check for outdated software
        vulnerabilities.extend(self._check_installed_software())

        # Check for insecure services
        vulnerabilities.extend(self._check_windows_services())

        return vulnerabilities

    def _check_package_updates(self) -> List[Vulnerability]:
        """Check for outdated packages (Linux)"""
        vulnerabilities = []

        try:
            # Check for available updates
            result = subprocess.run(
                ['apt', 'list', '--upgradable'],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0:
                upgradable = result.stdout.split('\n')[1:]  # Skip header
                security_updates = [pkg for pkg in upgradable if 'security' in pkg.lower()]

                if security_updates:
                    vulnerabilities.append(Vulnerability(
                        id="LINUX-001",
                        name="Outdated Security Packages",
                        description=f"{len(security_updates)} security updates available",
                        severity=VulnerabilitySeverity.HIGH,
                        category="patch_management",
                        affected_component="Package Manager",
                        remediation="Run: sudo apt update && sudo apt upgrade",
                        cve_id=None,
                        is_patchable=True,
                        requires_restart=False
                    ))

        except:
            pass

        return vulnerabilities

    def _check_ssh_config(self) -> List[Vulnerability]:
        """Check SSH configuration for security issues"""
        vulnerabilities = []
        sshd_config = "/etc/ssh/sshd_config"

        if not os.path.exists(sshd_config):
            return vulnerabilities

        try:
            with open(sshd_config, 'r') as f:
                config = f.read()

            # Check root login
            if re.search(r'^PermitRootLogin\s+yes', config, re.MULTILINE | re.IGNORECASE):
                vulnerabilities.append(Vulnerability(
                    id="LINUX-002",
                    name="SSH Root Login Enabled",
                    description="Root login via SSH is permitted",
                    severity=VulnerabilitySeverity.HIGH,
                    category="access_control",
                    affected_component="SSH Server",
                    remediation="Set 'PermitRootLogin no' in /etc/ssh/sshd_config",
                    cve_id=None,
                    is_patchable=True,
                    requires_restart=True
                ))

            # Check password authentication
            if re.search(r'^PasswordAuthentication\s+yes', config, re.MULTILINE | re.IGNORECASE):
                vulnerabilities.append(Vulnerability(
                    id="LINUX-003",
                    name="SSH Password Authentication Enabled",
                    description="Password authentication allows brute force attacks",
                    severity=VulnerabilitySeverity.MEDIUM,
                    category="access_control",
                    affected_component="SSH Server",
                    remediation="Set 'PasswordAuthentication no' and use SSH keys",
                    cve_id=None,
                    is_patchable=True,
                    requires_restart=True
                ))

            # Check for empty passwords
            if re.search(r'^PermitEmptyPasswords\s+yes', config, re.MULTILINE | re.IGNORECASE):
                vulnerabilities.append(Vulnerability(
                    id="LINUX-004",
                    name="SSH Empty Passwords Permitted",
                    description="Empty passwords are allowed for SSH",
                    severity=VulnerabilitySeverity.CRITICAL,
                    category="access_control",
                    affected_component="SSH Server",
                    remediation="Set 'PermitEmptyPasswords no' in /etc/ssh/sshd_config",
                    cve_id=None,
                    is_patchable=True,
                    requires_restart=True
                ))

        except:
            pass

        return vulnerabilities

    def _check_firewall_linux(self) -> List[Vulnerability]:
        """Check Linux firewall status"""
        vulnerabilities = []

        try:
            # Check iptables
            result = subprocess.run(
                ['iptables', '-L'],
                capture_output=True,
                timeout=5
            )

            # If iptables has minimal rules, firewall might be inactive
            if len(result.stdout.split('\n')) < 10:
                vulnerabilities.append(Vulnerability(
                    id="LINUX-005",
                    name="Firewall Inactive or Minimal Rules",
                    description="No significant firewall rules detected",
                    severity=VulnerabilitySeverity.MEDIUM,
                    category="network_security",
                    affected_component="iptables",
                    remediation="Configure firewall rules or enable UFW",
                    cve_id=None,
                    is_patchable=True,
                    requires_restart=False
                ))

        except:
            pass

        # Check UFW status
        try:
            result = subprocess.run(
                ['ufw', 'status'],
                capture_output=True,
                text=True,
                timeout=5
            )

            if 'inactive' in result.stdout.lower():
                vulnerabilities.append(Vulnerability(
                    id="LINUX-006",
                    name="UFW Firewall Disabled",
                    description="Uncomplicated Firewall (UFW) is not active",
                    severity=VulnerabilitySeverity.MEDIUM,
                    category="network_security",
                    affected_component="UFW",
                    remediation="Run: sudo ufw enable",
                    cve_id=None,
                    is_patchable=True,
                    requires_restart=False
                ))

        except:
            pass

        return vulnerabilities

    def _check_world_writable(self) -> List[Vulnerability]:
        """Check for world-writable files in system directories"""
        vulnerabilities = []

        system_dirs = ['/bin', '/sbin', '/usr/bin', '/usr/sbin', '/etc']

        try:
            for directory in system_dirs:
                if os.path.exists(directory):
                    result = subprocess.run(
                        ['find', directory, '-perm', '-002', '-type', 'f'],
                        capture_output=True,
                        text=True,
                        timeout=30
                    )

                    if result.stdout.strip():
                        count = len(result.stdout.strip().split('\n'))
                        vulnerabilities.append(Vulnerability(
                            id=f"LINUX-007-{directory}",
                            name="World-Writable System Files",
                            description=f"{count} world-writable files in {directory}",
                            severity=VulnerabilitySeverity.HIGH,
                            category="file_permissions",
                            affected_component=directory,
                            remediation=f"Review and fix permissions: chmod o-w <files>",
                            cve_id=None,
                            is_patchable=True,
                            requires_restart=False
                        ))

        except:
            pass

        return vulnerabilities

    def _check_suid_binaries(self) -> List[Vulnerability]:
        """Check for suspicious SUID binaries"""
        vulnerabilities = []

        try:
            result = subprocess.run(
                ['find', '/', '-perm', '-4000', '-type', 'f'],
                capture_output=True,
                text=True,
                timeout=60
            )

            suid_binaries = result.stdout.strip().split('\n')

            # Known safe SUID binaries
            safe_suid = [
                '/usr/bin/sudo', '/usr/bin/passwd', '/usr/bin/su',
                '/usr/bin/ping', '/usr/bin/mount', '/usr/bin/umount',
                '/usr/bin/chsh', '/usr/bin/chfn', '/usr/bin/gpasswd',
                '/usr/bin/newgrp', '/usr/bin/at', '/usr/bin/chage'
            ]

            suspicious = [b for b in suid_binaries if b and b not in safe_suid]

            if len(suspicious) > 5:  # Threshold for suspicious
                vulnerabilities.append(Vulnerability(
                    id="LINUX-008",
                    name="Suspicious SUID Binaries",
                    description=f"{len(suspicious)} non-standard SUID binaries found",
                    severity=VulnerabilitySeverity.MEDIUM,
                    category="privilege_escalation",
                    affected_component="File System",
                    remediation="Review SUID binaries and remove unnecessary ones",
                    cve_id=None,
                    is_patchable=True,
                    requires_restart=False
                ))

        except:
            pass

        return vulnerabilities

    def _check_password_policies(self) -> List[Vulnerability]:
        """Check password policies"""
        vulnerabilities = []

        login_defs = "/etc/login.defs"

        if os.path.exists(login_defs):
            try:
                with open(login_defs, 'r') as f:
                    config = f.read()

                # Check password length
                pass_min_len = re.search(r'^PASS_MIN_LEN\s+(\d+)', config, re.MULTILINE)
                if pass_min_len and int(pass_min_len.group(1)) < 8:
                    vulnerabilities.append(Vulnerability(
                        id="LINUX-009",
                        name="Weak Password Length Policy",
                        description=f"Minimum password length is {pass_min_len.group(1)} (should be 8+)",
                        severity=VulnerabilitySeverity.MEDIUM,
                        category="authentication",
                        affected_component="Password Policy",
                        remediation="Set PASS_MIN_LEN to at least 8 in /etc/login.defs",
                        cve_id=None,
                        is_patchable=True,
                        requires_restart=False
                    ))

            except:
                pass

        return vulnerabilities

    def _check_auto_updates(self) -> List[Vulnerability]:
        """Check if automatic updates are enabled"""
        vulnerabilities = []

        # Check for unattended-upgrades
        if not os.path.exists('/etc/apt/apt.conf.d/20auto-upgrades'):
            vulnerabilities.append(Vulnerability(
                id="LINUX-010",
                name="Automatic Updates Not Configured",
                description="System may miss critical security updates",
                severity=VulnerabilitySeverity.MEDIUM,
                category="patch_management",
                affected_component="Package Manager",
                remediation="Install and configure unattended-upgrades",
                cve_id=None,
                is_patchable=True,
                requires_restart=False
            ))

        return vulnerabilities

    def _check_defender_status(self) -> List[Vulnerability]:
        """Check Windows Defender status"""
        vulnerabilities = []

        try:
            result = subprocess.run(
                ['powershell', '-Command', 'Get-MpComputerStatus'],
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode == 0:
                # Check if real-time protection is enabled
                if 'RealTimeProtectionEnabled' in result.stdout:
                    if 'False' in result.stdout.split('RealTimeProtectionEnabled')[1].split('\n')[0]:
                        vulnerabilities.append(Vulnerability(
                            id="WIN-001",
                            name="Windows Defender Real-Time Protection Disabled",
                            description="Real-time protection is not active",
                            severity=VulnerabilitySeverity.CRITICAL,
                            category="antimalware",
                            affected_component="Windows Defender",
                            remediation="Enable Windows Defender real-time protection",
                            cve_id=None,
                            is_patchable=True,
                            requires_restart=False
                        ))

        except:
            pass

        return vulnerabilities

    def _check_windows_update(self) -> List[Vulnerability]:
        """Check Windows Update status"""
        vulnerabilities = []

        try:
            result = subprocess.run(
                ['powershell', '-Command', 'Get-WindowsUpdate'],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0 and result.stdout.strip():
                # Updates available
                lines = [l for l in result.stdout.split('\n') if l.strip()]
                if len(lines) > 1:
                    vulnerabilities.append(Vulnerability(
                        id="WIN-002",
                        name="Windows Updates Pending",
                        description=f"{len(lines)} Windows updates are available",
                        severity=VulnerabilitySeverity.HIGH,
                        category="patch_management",
                        affected_component="Windows Update",
                        remediation="Install pending Windows updates",
                        cve_id=None,
                        is_patchable=True,
                        requires_restart=True
                    ))

        except:
            pass

        return vulnerabilities

    def _check_firewall_windows(self) -> List[Vulnerability]:
        """Check Windows Firewall status"""
        vulnerabilities = []

        try:
            result = subprocess.run(
                ['netsh', 'advfirewall', 'show', 'allprofiles', 'state'],
                capture_output=True,
                text=True,
                timeout=10
            )

            if 'OFF' in result.stdout:
                vulnerabilities.append(Vulnerability(
                    id="WIN-003",
                    name="Windows Firewall Disabled",
                    description="One or more firewall profiles are disabled",
                    severity=VulnerabilitySeverity.HIGH,
                    category="network_security",
                    affected_component="Windows Firewall",
                    remediation="Enable Windows Firewall for all profiles",
                    cve_id=None,
                    is_patchable=True,
                    requires_restart=False
                ))

        except:
            pass

        return vulnerabilities

    def _check_uac(self) -> List[Vulnerability]:
        """Check User Account Control status"""
        vulnerabilities = []

        try:
            result = subprocess.run(
                ['powershell', '-Command', 'Get-ItemProperty HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System'],
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode == 0:
                # Check EnableLUA
                if 'EnableLUA' in result.stdout:
                    match = re.search(r'EnableLUA\s*:\s*(\d+)', result.stdout)
                    if match and match.group(1) == '0':
                        vulnerabilities.append(Vulnerability(
                            id="WIN-004",
                            name="UAC Disabled",
                            description="User Account Control is disabled",
                            severity=VulnerabilitySeverity.HIGH,
                            category="access_control",
                            affected_component="UAC",
                            remediation="Enable UAC in Windows Security settings",
                            cve_id=None,
                            is_patchable=True,
                            requires_restart=False
                        ))

        except:
            pass

        return vulnerabilities

    def _check_installed_software(self) -> List[Vulnerability]:
        """Check for outdated/insecure software"""
        vulnerabilities = []

        # This is a simplified check - real implementation would have CVE database
        known_insecure = [
            'Adobe Flash Player',
            'Java 7',
            'Internet Explorer',
        ]

        try:
            result = subprocess.run(
                ['powershell', '-Command', 'Get-ItemProperty HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Select-Object DisplayName'],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0:
                for insecure in known_insecure:
                    if insecure.lower() in result.stdout.lower():
                        vulnerabilities.append(Vulnerability(
                            id=f"WIN-005-{insecure}",
                            name=f"Insecure Software: {insecure}",
                            description=f"{insecure} is installed and may have known vulnerabilities",
                            severity=VulnerabilitySeverity.HIGH,
                            category="software",
                            affected_component=insecure,
                            remediation=f"Uninstall {insecure} or update to latest version",
                            cve_id=None,
                            is_patchable=True,
                            requires_restart=False
                        ))

        except:
            pass

        return vulnerabilities

    def _check_windows_services(self) -> List[Vulnerability]:
        """Check for insecure Windows services"""
        vulnerabilities = []

        insecure_services = {
            'Telnet': 'Insecure protocol, should be disabled',
            'RemoteRegistry': 'Remote registry access is a security risk',
            'Fax': 'Unnecessary service, should be disabled',
        }

        try:
            for service, description in insecure_services.items():
                result = subprocess.run(
                    ['sc', 'query', service],
                    capture_output=True,
                    text=True,
                    timeout=5
                )

                if 'RUNNING' in result.stdout:
                    vulnerabilities.append(Vulnerability(
                        id=f"WIN-006-{service}",
                        name=f"Insecure Service Running: {service}",
                        description=description,
                        severity=VulnerabilitySeverity.MEDIUM,
                        category="services",
                        affected_component=service,
                        remediation=f"Disable {service} service",
                        cve_id=None,
                        is_patchable=True,
                        requires_restart=False
                    ))

        except:
            pass

        return vulnerabilities

    def _scan_network(self) -> List[Vulnerability]:
        """Scan for network vulnerabilities"""
        vulnerabilities = []

        # Check for open ports
        try:
            if self.platform == "linux":
                result = subprocess.run(
                    ['ss', '-tuln'],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
            else:  # Windows
                result = subprocess.run(
                    ['netstat', '-an'],
                    capture_output=True,
                    text=True,
                    timeout=10
                )

            # Check for risky open ports
            risky_ports = {
                21: "FTP (unencrypted)",
                23: "Telnet (insecure)",
                25: "SMTP (may be abused)",
                135: "RPC (attack surface)",
                139: "NetBIOS (legacy)",
                445: "SMB (attack surface)",
                3389: "RDP (remote access)",
            }

            for port, desc in risky_ports.items():
                if f':{port}' in result.stdout:
                    vulnerabilities.append(Vulnerability(
                        id=f"NET-001-{port}",
                        name=f"Open Port: {port}",
                        description=f"{desc} is exposed",
                        severity=VulnerabilitySeverity.MEDIUM,
                        category="network_security",
                        affected_component="Network",
                        remediation=f"Close port {port} if not required",
                        cve_id=None,
                        is_patchable=True,
                        requires_restart=False
                    ))

        except:
            pass

        return vulnerabilities

    def _scan_services(self) -> List[Vulnerability]:
        """Scan for service vulnerabilities"""
        vulnerabilities = []

        # This would include checks for:
        # - Outdated web servers (Apache, Nginx)
        # - Database security (MySQL, PostgreSQL)
        # - Container security (Docker)
        # - Cloud metadata endpoints

        # Placeholder for now
        return vulnerabilities

    def get_scan_report(self) -> Dict:
        """Generate comprehensive scan report"""
        severity_counts = {
            VulnerabilitySeverity.CRITICAL: 0,
            VulnerabilitySeverity.HIGH: 0,
            VulnerabilitySeverity.MEDIUM: 0,
            VulnerabilitySeverity.LOW: 0,
            VulnerabilitySeverity.INFO: 0,
        }

        category_vulns = {}

        for vuln in self.detected_vulnerabilities:
            severity_counts[vuln.severity] += 1

            if vuln.category not in category_vulns:
                category_vulns[vuln.category] = []
            category_vulns[vuln.category].append(vuln.name)

        return {
            "platform": self.platform,
            "total_vulnerabilities": len(self.detected_vulnerabilities),
            "by_severity": {s.value: c for s, c in severity_counts.items()},
            "by_category": category_vulns,
            "vulnerabilities": [
                {
                    "id": v.id,
                    "name": v.name,
                    "severity": v.severity.value,
                    "category": v.category,
                    "affected": v.affected_component,
                    "patchable": v.is_patchable
                }
                for v in self.detected_vulnerabilities
            ]
        }


# Example usage
if __name__ == "__main__":
    print("=" * 60)
    print("üîí Security Scanner - Benevolent Protocol")
    print("=" * 60)
    print()

    scanner = SecurityScanner()

    print(f"Platform: {scanner.platform.upper()}")
    print("\nüîç Scanning for vulnerabilities...\n")

    vulnerabilities = scanner.scan_system()

    if vulnerabilities:
        print(f"üìä Found {len(vulnerabilities)} vulnerabilities:\n")

        # Group by severity
        by_severity = {}
        for vuln in vulnerabilities:
            if vuln.severity not in by_severity:
                by_severity[vuln.severity] = []
            by_severity[vuln.severity].append(vuln)

        # Show by severity (highest first)
        for severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH,
                         VulnerabilitySeverity.MEDIUM, VulnerabilitySeverity.LOW]:
            if severity in by_severity:
                print(f"{severity.value.upper()} ({len(by_severity[severity])}):")
                for vuln in by_severity[severity]:
                    print(f"  ‚Ä¢ {vuln.id}: {vuln.name}")
                    print(f"    {vuln.description}")
                    print(f"    Fix: {vuln.remediation}")
                    print()
    else:
        print("‚úÖ No vulnerabilities detected")

    print("\n‚úÖ Security scan complete")
