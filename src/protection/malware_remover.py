"""
Malware Remover Module
Safely removes detected malware threats
"""

import os
import subprocess
import time
from typing import List, Tuple, Optional
from dataclasses import dataclass

from .malware_scanner import MalwareThreat, ThreatLevel, ThreatType


@dataclass
class RemovalResult:
    """Result of malware removal attempt"""
    threat_id: str
    threat_name: str
    action: str
    success: bool
    message: str
    requires_restart: bool
    backup_path: Optional[str]  # If file was backed up


class MalwareRemover:
    """
    Safely removes malware threats.
    Quarantines files before removal, logs all actions.
    """

    def __init__(self):
        self.quarantine_dir = "/tmp/benevolent_protocol_quarantine"
        self.removal_log = []
        self.removal_results: List[RemovalResult] = []

    def remove_threats(self, threats: List[MalwareThreat]) -> List[RemovalResult]:
        """
        Remove multiple threats.
        Returns list of removal results.
        """
        results = []

        for threat in threats:
            if not threat.is_removable:
                results.append(RemovalResult(
                    threat_id=threat.id,
                    threat_name=threat.name,
                    action="skip",
                    success=False,
                    message="Threat requires manual intervention",
                    requires_restart=threat.requires_restart,
                    backup_path=None
                ))
                continue

            result = self._remove_threat(threat)
            if result:
                results.append(result)
                self.removal_results.append(result)

        return results

    def _remove_threat(self, threat: MalwareThreat) -> Optional[RemovalResult]:
        """Remove a single threat"""

        # File-based threat
        if threat.file_path:
            return self._remove_file(threat)

        # Process-based threat
        if threat.process_name:
            return self._kill_process(threat)

        # Behavior-based threat
        return self._mitigate_behavior(threat)

    def _remove_file(self, threat: MalwareThreat) -> RemovalResult:
        """Remove malicious file"""
        file_path = threat.file_path

        if not os.path.exists(file_path):
            return RemovalResult(
                threat_id=threat.id,
                threat_name=threat.name,
                action="file_removal",
                success=False,
                message=f"File not found: {file_path}",
                requires_restart=False,
                backup_path=None
            )

        try:
            # Quarantine file first
            backup_path = self._quarantine_file(file_path)

            # Remove original file
            os.remove(file_path)

            # Log removal
            self._log_removal(threat, file_path, backup_path)

            return RemovalResult(
                threat_id=threat.id,
                threat_name=threat.name,
                action="file_removal",
                success=True,
                message=f"Removed: {file_path}",
                requires_restart=threat.requires_restart,
                backup_path=backup_path
            )

        except Exception as e:
            return RemovalResult(
                threat_id=threat.id,
                threat_name=threat.name,
                action="file_removal",
                success=False,
                message=f"Failed to remove {file_path}: {e}",
                requires_restart=False,
                backup_path=None
            )

    def _kill_process(self, threat: MalwareThreat) -> RemovalResult:
        """Kill malicious process"""
        process_name = threat.process_name

        try:
            # Find process ID
            result = subprocess.run(
                ["pgrep", "-f", process_name],
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode == 0:
                pids = result.stdout.strip().split('\n')

                for pid in pids:
                    if pid:
                        # Kill process
                        subprocess.run(
                            ["kill", "-9", pid],
                            check=True,
                            timeout=5
                        )

                return RemovalResult(
                    threat_id=threat.id,
                    threat_name=threat.name,
                    action="process_kill",
                    success=True,
                    message=f"Killed {len(pids)} instances of {process_name}",
                    requires_restart=False,
                    backup_path=None
                )
            else:
                return RemovalResult(
                    threat_id=threat.id,
                    threat_name=threat.name,
                    action="process_kill",
                    success=False,
                    message=f"Process not found: {process_name}",
                    requires_restart=False,
                    backup_path=None
                )

        except Exception as e:
            return RemovalResult(
                threat_id=threat.id,
                threat_name=threat.name,
                action="process_kill",
                success=False,
                message=f"Failed to kill {process_name}: {e}",
                requires_restart=False,
                backup_path=None
            )

    def _mitigate_behavior(self, threat: MalwareThreat) -> RemovalResult:
        """Mitigate behavior-based threat"""

        # Ransomware
        if threat.threat_type == ThreatType.RANSOMWARE:
            return RemovalResult(
                threat_id=threat.id,
                threat_name=threat.name,
                action="behavior_mitigation",
                success=False,
                message="Ransomware detected! Immediate manual intervention required. Disconnect from network!",
                requires_restart=False,
                backup_path=None
            )

        # Rootkit
        if threat.threat_type == ThreatType.ROOTKIT:
            return RemovalResult(
                threat_id=threat.id,
                threat_name=threat.name,
                action="behavior_mitigation",
                success=False,
                message="Rootkit detected! Requires expert analysis and removal. Consider full system reinstall.",
                requires_restart=True,
                backup_path=None
            )

        # Cryptominer behavior
        if threat.threat_type == ThreatType.CRYPTOMINER:
            # Try to identify and kill cryptominer process
            return RemovalResult(
                threat_id=threat.id,
                threat_name=threat.name,
                action="behavior_mitigation",
                success=False,
                message="Cryptominer behavior detected. Run process scan to identify and remove.",
                requires_restart=False,
                backup_path=None
            )

        return RemovalResult(
            threat_id=threat.id,
            threat_name=threat.name,
            action="behavior_mitigation",
            success=False,
            message="Behavior-based threat requires manual investigation",
            requires_restart=False,
            backup_path=None
        )

    def _quarantine_file(self, file_path: str) -> str:
        """Quarantine file before removal"""
        if not os.path.exists(self.quarantine_dir):
            os.makedirs(self.quarantine_dir)

        # Create quarantine filename
        filename = os.path.basename(file_path)
        quarantine_name = f"{filename}.{int(time.time())}.quarantine"
        quarantine_path = os.path.join(self.quarantine_dir, quarantine_name)

        # Move file to quarantine
        import shutil
        shutil.move(file_path, quarantine_path)

        # Make file non-executable
        os.chmod(quarantine_path, 0o000)

        return quarantine_path

    def _log_removal(self, threat: MalwareThreat, file_path: str, backup_path: str) -> None:
        """Log removal action"""
        log_entry = {
            "timestamp": time.time(),
            "threat_id": threat.id,
            "threat_name": threat.name,
            "threat_type": threat.threat_type.value,
            "threat_level": threat.threat_level.value,
            "file_path": file_path,
            "backup_path": backup_path,
            "action": "removed"
        }

        self.removal_log.append(log_entry)

        # Write to log file
        log_file = os.path.join(self.quarantine_dir, "removal_log.txt")
        with open(log_file, 'a') as f:
            f.write(f"{log_entry}\n")

    def restore_from_quarantine(self, quarantine_path: str, restore_path: str) -> bool:
        """Restore file from quarantine"""
        try:
            import shutil
            shutil.move(quarantine_path, restore_path)

            # Restore permissions
            os.chmod(restore_path, 0o644)

            return True

        except Exception as e:
            print(f"Failed to restore: {e}")
            return False

    def get_removal_report(self) -> dict:
        """Generate removal report"""
        successful = [r for r in self.removal_results if r.success]
        failed = [r for r in self.removal_results if not r.success]

        return {
            "total_removals": len(self.removal_results),
            "successful": len(successful),
            "failed": len(failed),
            "requires_restart": any(r.requires_restart for r in successful),
            "quarantine_dir": self.quarantine_dir,
            "removals": [
                {
                    "threat": r.threat_name,
                    "action": r.action,
                    "success": r.success,
                    "message": r.message,
                    "backup": r.backup_path
                }
                for r in self.removal_results
            ]
        }


# Example usage
if __name__ == "__main__":
    from malware_scanner import MalwareScanner

    print("=" * 60)
    print("ü¶† Malware Remover - Benevolent Protocol")
    print("=" * 60)
    print()

    # Scan first
    scanner = MalwareScanner()
    threats = scanner.scan_system(quick_scan=True)

    print(f"Found {len(threats)} threats\n")

    # Remove
    remover = MalwareRemover()
    results = remover.remove_threats(threats)

    print(f"Removal Results:\n")

    for result in results:
        status = "‚úÖ" if result.success else "‚ùå"
        print(f"{status} {result.threat_name}")
        print(f"   Action: {result.action}")
        print(f"   {result.message}")
        if result.backup_path:
            print(f"   Backup: {result.backup_path}")
        print()

    print(f"\nQuarantine directory: {remover.quarantine_dir}")
    print("\n‚úÖ Malware removal complete")
