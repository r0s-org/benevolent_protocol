"""
Malware Scanner Module
Detects and removes malicious software
"""

import os
import re
import subprocess
import hashlib
import time
from typing import List, Dict, Optional, Set, Tuple
from dataclasses import dataclass
from enum import Enum
import platform


class ThreatLevel(Enum):
    """Threat severity levels"""
    CRITICAL = "critical"    # Active malware, immediate danger
    HIGH = "high"           # Malware detected, significant risk
    MEDIUM = "medium"       # Suspicious, potential threat
    LOW = "low"             # Minor concern, PUA
    INFO = "info"           # Informational, no immediate threat


class ThreatType(Enum):
    """Types of threats"""
    VIRUS = "virus"
    TROJAN = "trojan"
    WORM = "worm"
    RANSOMWARE = "ransomware"
    SPYWARE = "spyware"
    ADWARE = "adware"
    ROOTKIT = "rootkit"
    CRYPTOMINER = "cryptominer"
    BACKDOOR = "backdoor"
    PUP = "potentially_unwanted_program"
    UNKNOWN = "unknown"


@dataclass
class MalwareThreat:
    """Represents a detected malware threat"""
    id: str
    name: str
    threat_type: ThreatType
    threat_level: ThreatLevel
    file_path: Optional[str]
    process_name: Optional[str]
    description: str
    indicators: List[str]  # What triggered detection
    is_removable: bool
    requires_restart: bool
    hash: Optional[str]  # File hash if applicable


@dataclass
class MalwareSignature:
    """Malware signature for detection"""
    name: str
    threat_type: ThreatType
    threat_level: ThreatLevel
    file_hashes: List[str]  # Known malicious file hashes
    file_names: List[str]   # Known malicious file names
    process_names: List[str]  # Known malicious process names
    registry_keys: List[str]  # Known malicious registry keys (Windows)
    behaviors: List[str]     # Behavioral indicators
    description: str


class MalwareScanner:
    """
    Scans system for malware and malicious software.
    Uses signature-based and behavior-based detection.
    Cross-platform: Works on Linux and Windows.
    """

    def __init__(self):
        self.platform = platform.system().lower()
        self.detected_threats: List[MalwareThreat] = []
        self.signatures = self._load_signatures()
        self.scan_paths = self._get_scan_paths()

    def _load_signatures(self) -> List[MalwareSignature]:
        """
        Load malware signatures database.
        In production, this would load from a database.
        """
        return [
            # Common cryptominers
            MalwareSignature(
                name="XMRig Cryptominer",
                threat_type=ThreatType.CRYPTOMINER,
                threat_level=ThreatLevel.HIGH,
                file_hashes=[
                    "a1b2c3d4e5f67890",  # Placeholder - real implementation would have actual hashes
                ],
                file_names=["xmrig.exe", "xmrig", "minerd", "cpuminer"],
                process_names=["xmrig", "minerd", "cpuminer", "systemd-miner"],
                registry_keys=[],
                behaviors=["high_cpu_usage", "network_mining_pool"],
                description="Cryptocurrency mining malware"
            ),
            MalwareSignature(
                name="CoinHive JavaScript Miner",
                threat_type=ThreatType.CRYPTOMINER,
                threat_level=ThreatLevel.MEDIUM,
                file_hashes=[],
                file_names=["coinhive.min.js", "authedmine.js"],
                process_names=[],
                registry_keys=[],
                behaviors=["browser_mining_script"],
                description="Browser-based cryptocurrency miner"
            ),

            # Common adware
            MalwareSignature(
                name="Adware.Gen",
                threat_type=ThreatType.ADWARE,
                threat_level=ThreatLevel.LOW,
                file_hashes=[],
                file_names=["adware.exe", "popup.exe"],
                process_names=["adware", "popupgen"],
                registry_keys=[],
                behaviors=["excessive_ads", "browser_hijack"],
                description="Generic adware"
            ),

            # Common PUPs (Potentially Unwanted Programs)
            MalwareSignature(
                name="Cleaner PUP",
                threat_type=ThreatType.PUP,
                threat_level=ThreatLevel.LOW,
                file_hashes=[],
                file_names=["cleanmaster.exe", "pc-cleaner.exe", "speedup.exe"],
                process_names=["cleanmaster", "pccleaner"],
                registry_keys=[],
                behaviors=["fake_scan", "scareware"],
                description="Potentially unwanted cleaner program"
            ),

            # Ransomware indicators
            MalwareSignature(
                name="Ransomware.Indicator",
                threat_type=ThreatType.RANSOMWARE,
                threat_level=ThreatLevel.CRITICAL,
                file_hashes=[],
                file_names=[],
                process_names=[],
                registry_keys=[],
                behaviors=[
                    "mass_file_encryption",
                    "ransom_note_creation",
                    "shadow_copy_deletion",
                    "backup_deletion"
                ],
                description="Ransomware behavior detected"
            ),

            # Spyware
            MalwareSignature(
                name="Keylogger.Generic",
                threat_type=ThreatType.SPYWARE,
                threat_level=ThreatLevel.HIGH,
                file_hashes=[],
                file_names=["keylog.exe", "logger.exe"],
                process_names=["keylogger", "keylog"],
                registry_keys=[],
                behaviors=["keyboard_hooking", "clipboard_monitoring"],
                description="Keylogger detected"
            ),

            # Backdoors
            MalwareSignature(
                name="Backdoor.Generic",
                threat_type=ThreatType.BACKDOOR,
                threat_level=ThreatLevel.CRITICAL,
                file_hashes=[],
                file_names=["backdoor.exe", "bd.exe"],
                process_names=["backdoor", "remote_shell"],
                registry_keys=[],
                behaviors=["reverse_shell", "unauthorized_remote_access"],
                description="Backdoor detected"
            ),

            # Rootkits
            MalwareSignature(
                name="Rootkit.Indicator",
                threat_type=ThreatType.ROOTKIT,
                threat_level=ThreatLevel.CRITICAL,
                file_hashes=[],
                file_names=[],
                process_names=[],
                registry_keys=[],
                behaviors=[
                    "hidden_processes",
                    "hidden_files",
                    "kernel_modifications",
                    "bootkit_indicators"
                ],
                description="Rootkit behavior detected"
            ),

            # Linux-specific malware
            MalwareSignature(
                name="Linux.Ekoms",
                threat_type=ThreatType.TROJAN,
                threat_level=ThreatLevel.HIGH,
                file_hashes=[],
                file_names=["ekoms", ".ekoms"],
                process_names=["ekoms"],
                registry_keys=[],
                behaviors=["hidden_cron_jobs", "persistence"],
                description="Linux trojan"
            ),
            MalwareSignature(
                name="Linux.XorDDoS",
                threat_type=ThreatType.TROJAN,
                threat_level=ThreatLevel.HIGH,
                file_hashes=[],
                file_names=["xor-ddos", ".xorddos"],
                process_names=["xor-ddos"],
                registry_keys=[],
                behaviors=["ddos_botnet", "persistence"],
                description="Linux DDoS trojan"
            ),
            MalwareSignature(
                name="Linux.BillGates",
                threat_type=ThreatType.TROJAN,
                threat_level=ThreatLevel.HIGH,
                file_hashes=[],
                file_names=["billgates", ".billgates"],
                process_names=["billgates"],
                registry_keys=[],
                behaviors=["ddos_botnet", "backdoor"],
                description="Linux botnet malware"
            ),
        ]

    def _get_scan_paths(self) -> List[str]:
        """Get paths to scan for malware"""
        if self.platform == "linux":
            return [
                "/tmp",
                "/var/tmp",
                "/dev/shm",
                os.path.expanduser("~/.config"),
                os.path.expanduser("~/.local/share"),
                "/usr/local/bin",
                "/opt",
            ]
        else:  # Windows
            return [
                os.path.join(os.environ.get("TEMP", "C:\\Windows\\Temp")),
                os.path.join(os.environ.get("APPDATA", "C:\\Users")),
                os.path.join(os.environ.get("LOCALAPPDATA", "C:\\Users")),
                "C:\\ProgramData",
                "C:\\Windows\\Temp",
            ]

    def scan_system(self, quick_scan: bool = False) -> List[MalwareThreat]:
        """
        Perform malware scan.
        Returns list of detected threats.
        """
        threats = []

        print("ðŸ” Starting malware scan...\n")

        # Process-based detection
        print("   Scanning running processes...")
        threats.extend(self._scan_processes())

        # File-based detection
        if not quick_scan:
            print("   Scanning file system...")
            threats.extend(self._scan_files())

        # Behavior-based detection
        print("   Analyzing system behavior...")
        threats.extend(self._scan_behaviors())

        # Platform-specific scans
        if self.platform == "linux":
            threats.extend(self._scan_linux_specific())
        elif self.platform == "windows":
            threats.extend(self._scan_windows_specific())

        # Remove duplicates
        seen = set()
        unique_threats = []
        for threat in threats:
            if threat.id not in seen:
                seen.add(threat.id)
                unique_threats.append(threat)

        self.detected_threats = unique_threats
        return unique_threats

    def _scan_processes(self) -> List[MalwareThreat]:
        """Scan running processes for malware"""
        threats = []

        try:
            if self.platform == "linux":
                result = subprocess.run(
                    ["ps", "aux"],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
            else:  # Windows
                result = subprocess.run(
                    ["tasklist"],
                    capture_output=True,
                    text=True,
                    timeout=10
                )

            if result.returncode == 0:
                processes = result.stdout.lower()

                # Check against signatures
                for sig in self.signatures:
                    for proc_name in sig.process_names:
                        if proc_name.lower() in processes:
                            threats.append(MalwareThreat(
                                id=f"PROC-{sig.name}-{int(time.time())}",
                                name=sig.name,
                                threat_type=sig.threat_type,
                                threat_level=sig.threat_level,
                                file_path=None,
                                process_name=proc_name,
                                description=sig.description,
                                indicators=[f"Malicious process running: {proc_name}"],
                                is_removable=True,
                                requires_restart=False,
                                hash=None
                            ))

        except Exception as e:
            print(f"      Error scanning processes: {e}")

        return threats

    def _scan_files(self) -> List[MalwareThreat]:
        """Scan files for malware"""
        threats = []

        for scan_path in self.scan_paths:
            if not os.path.exists(scan_path):
                continue

            print(f"      Scanning {scan_path}...")

            try:
                for root, dirs, files in os.walk(scan_path):
                    for file in files:
                        file_path = os.path.join(root, file)

                        try:
                            # Check file names against signatures
                            for sig in self.signatures:
                                # Check file name
                                if file.lower() in [f.lower() for f in sig.file_names]:
                                    threats.append(MalwareThreat(
                                        id=f"FILE-{sig.name}-{int(time.time())}",
                                        name=sig.name,
                                        threat_type=sig.threat_type,
                                        threat_level=sig.threat_level,
                                        file_path=file_path,
                                        process_name=None,
                                        description=sig.description,
                                        indicators=[f"Malicious file detected: {file}"],
                                        is_removable=True,
                                        requires_restart=False,
                                        hash=self._get_file_hash(file_path)
                                    ))

                            # Check for suspicious extensions in sensitive locations
                            suspicious_extensions = [".exe", ".scr", ".bat", ".cmd", ".vbs", ".ps1"]
                            if self.platform == "linux":
                                suspicious_extensions = [".sh", ".py", ".pl"]

                            if any(file.lower().endswith(ext) for ext in suspicious_extensions):
                                # Check if in unusual location
                                if any(loc in file_path for loc in ["/tmp", "/var/tmp", "Temp", "AppData"]):
                                    # Could be suspicious - add to scan results for review
                                    pass  # Handled by behavior detection

                        except (PermissionError, OSError):
                            pass

            except Exception as e:
                print(f"      Error scanning {scan_path}: {e}")

        return threats

    def _scan_behaviors(self) -> List[MalwareThreat]:
        """Scan for malicious behaviors"""
        threats = []

        # Check for ransomware behavior
        if self._detect_ransomware_behavior():
            threats.append(MalwareThreat(
                id=f"BEHAVIOR-Ransomware-{int(time.time())}",
                name="Ransomware.Behavior",
                threat_type=ThreatType.RANSOMWARE,
                threat_level=ThreatLevel.CRITICAL,
                file_path=None,
                process_name=None,
                description="Ransomware-like behavior detected",
                indicators=["Mass file encryption", "Ransom notes", "Shadow copy deletion"],
                is_removable=False,  # Requires immediate action
                requires_restart=False,
                hash=None
            ))

        # Check for cryptominer behavior
        if self._detect_cryptomining_behavior():
            threats.append(MalwareThreat(
                id=f"BEHAVIOR-Cryptominer-{int(time.time())}",
                name="Cryptominer.Behavior",
                threat_type=ThreatType.CRYPTOMINER,
                threat_level=ThreatLevel.HIGH,
                file_path=None,
                process_name=None,
                description="Cryptocurrency mining behavior detected",
                indicators=["High CPU usage", "Mining pool connections"],
                is_removable=True,
                requires_restart=False,
                hash=None
            ))

        # Check for rootkit behavior
        if self._detect_rootkit_behavior():
            threats.append(MalwareThreat(
                id=f"BEHAVIOR-Rootkit-{int(time.time())}",
                name="Rootkit.Behavior",
                threat_type=ThreatType.ROOTKIT,
                threat_level=ThreatLevel.CRITICAL,
                file_path=None,
                process_name=None,
                description="Rootkit-like behavior detected",
                indicators=["Hidden processes", "System modifications"],
                is_removable=False,  # Requires expert intervention
                requires_restart=True,
                hash=None
            ))

        return threats

    def _detect_ransomware_behavior(self) -> bool:
        """Detect ransomware-like behavior"""
        try:
            # Check for mass file encryption
            # Look for many files with encrypted extensions in short time
            encrypted_extensions = [
                ".encrypted", ".locked", ".crypto", ".crypt",
                ".ransom", ".locked", ".enc", ".cz"
            ]

            # Check for ransom notes
            ransom_notes = [
                "readme.txt", "decrypt_instructions.txt",
                "how_to_decrypt.txt", "restore_files.txt"
            ]

            # Simplified check - real implementation would be more sophisticated
            for scan_path in self.scan_paths[:2]:  # Check first 2 paths only
                if os.path.exists(scan_path):
                    for root, dirs, files in os.walk(scan_path):
                        for file in files:
                            if any(note in file.lower() for note in ransom_notes):
                                return True

        except:
            pass

        return False

    def _detect_cryptomining_behavior(self) -> bool:
        """Detect cryptocurrency mining behavior"""
        try:
            # Check for high CPU usage from suspicious processes
            if self.platform == "linux":
                result = subprocess.run(
                    ["ps", "aux", "--sort=-%cpu"],
                    capture_output=True,
                    text=True,
                    timeout=10
                )

                if result.returncode == 0:
                    lines = result.stdout.split('\n')[1:6]  # Top 5 CPU processes
                    for line in lines:
                        if line:
                            parts = line.split()
                            if len(parts) >= 3:
                                cpu_usage = float(parts[2])
                                proc_name = parts[10] if len(parts) > 10 else ""

                                # Suspicious if unknown process using >70% CPU
                                if cpu_usage > 70 and proc_name not in [
                                    "firefox", "chrome", "chromium",
                                    "code", "idea", "pycharm",
                                    "blender", "ffmpeg", "make"
                                ]:
                                    return True

        except:
            pass

        return False

    def _detect_rootkit_behavior(self) -> bool:
        """Detect rootkit behavior"""
        try:
            if self.platform == "linux":
                # Check for hidden processes
                # Compare /proc with ps output
                proc_pids = set(os.listdir("/proc"))
                proc_pids = {p for p in proc_pids if p.isdigit()}

                result = subprocess.run(
                    ["ps", "-eo", "pid"],
                    capture_output=True,
                    text=True,
                    timeout=10
                )

                if result.returncode == 0:
                    ps_pids = set()
                    for line in result.stdout.split('\n')[1:]:
                        pid = line.strip()
                        if pid.isdigit():
                            ps_pids.add(pid)

                    # Hidden processes detected
                    hidden = proc_pids - ps_pids
                    if len(hidden) > 5:  # Threshold
                        return True

        except:
            pass

        return False

    def _scan_linux_specific(self) -> List[MalwareThreat]:
        """Linux-specific malware scans"""
        threats = []

        # Check for malicious cron jobs
        threats.extend(self._check_cron_jobs())

        # Check for suspicious startup scripts
        threats.extend(self._check_startup_scripts())

        # Check for modified system binaries
        threats.extend(self._check_system_binaries())

        return threats

    def _check_cron_jobs(self) -> List[MalwareThreat]:
        """Check for malicious cron jobs"""
        threats = []

        cron_paths = [
            "/etc/crontab",
            "/etc/cron.d",
            "/etc/cron.daily",
            "/etc/cron.hourly",
            "/etc/cron.weekly",
            "/etc/cron.monthly",
        ]

        suspicious_patterns = [
            "curl.*|.*sh",  # Download and execute
            "wget.*|.*sh",
            "base64 -d",    # Decode and execute
            "eval",
            "/dev/tcp",
            "nc -",
            "ncat -",
        ]

        try:
            for cron_path in cron_paths:
                if os.path.exists(cron_path):
                    if os.path.isfile(cron_path):
                        with open(cron_path, 'r') as f:
                            content = f.read()

                        for pattern in suspicious_patterns:
                            if re.search(pattern, content):
                                threats.append(MalwareThreat(
                                    id=f"CRON-{cron_path}-{int(time.time())}",
                                    name="Suspicious.Cron.Job",
                                    threat_type=ThreatType.TROJAN,
                                    threat_level=ThreatLevel.HIGH,
                                    file_path=cron_path,
                                    process_name=None,
                                    description="Suspicious cron job detected",
                                    indicators=[f"Pattern found: {pattern}"],
                                    is_removable=True,
                                    requires_restart=False,
                                    hash=None
                                ))
                                break

        except:
            pass

        return threats

    def _check_startup_scripts(self) -> List[MalwareThreat]:
        """Check for suspicious startup scripts"""
        threats = []

        startup_paths = [
            "/etc/init.d",
            "/etc/systemd/system",
            "/lib/systemd/system",
            os.path.expanduser("~/.config/autostart"),
        ]

        try:
            for startup_path in startup_paths:
                if os.path.exists(startup_path):
                    for root, dirs, files in os.walk(startup_path):
                        for file in files:
                            file_path = os.path.join(root, file)

                            try:
                                with open(file_path, 'r') as f:
                                    content = f.read().lower()

                                # Check for suspicious content
                                suspicious = ["curl", "wget", "base64", "/dev/tcp", "nc "]

                                if any(s in content for s in suspicious):
                                    # Check if it's a known safe service
                                    if not any(safe in file_path for safe in [
                                        "systemd-journald", "systemd-logind",
                                        "networking", "cron", "ssh"
                                    ]):
                                        threats.append(MalwareThreat(
                                            id=f"STARTUP-{file_path}-{int(time.time())}",
                                            name="Suspicious.Startup",
                                            threat_type=ThreatType.TROJAN,
                                            threat_level=ThreatLevel.MEDIUM,
                                            file_path=file_path,
                                            process_name=None,
                                            description="Suspicious startup script",
                                            indicators=["Network download in startup"],
                                            is_removable=True,
                                            requires_restart=True,
                                            hash=None
                                        ))

                            except:
                                pass

        except:
            pass

        return threats

    def _check_system_binaries(self) -> List[MalwareThreat]:
        """Check for modified system binaries"""
        threats = []

        # This would compare against known good hashes
        # Simplified for demonstration
        return threats

    def _scan_windows_specific(self) -> List[MalwareThreat]:
        """Windows-specific malware scans"""
        threats = []

        # Check for suspicious registry entries
        threats.extend(self._check_registry())

        # Check for suspicious scheduled tasks
        threats.extend(self._check_scheduled_tasks())

        return threats

    def _check_registry(self) -> List[MalwareThreat]:
        """Check Windows registry for malware"""
        threats = []

        # Registry keys commonly used by malware
        suspicious_keys = [
            r"HKCU\Software\Microsoft\Windows\CurrentVersion\Run",
            r"HKLM\Software\Microsoft\Windows\CurrentVersion\Run",
            r"HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce",
        ]

        try:
            for key in suspicious_keys:
                result = subprocess.run(
                    ["reg", "query", key],
                    capture_output=True,
                    text=True,
                    timeout=10
                )

                if result.returncode == 0:
                    # Check for suspicious entries
                    suspicious_patterns = [
                        "powershell -enc",
                        "cmd.exe /c",
                        "wscript",
                        "cscript",
                        "regsvr32",
                    ]

                    for pattern in suspicious_patterns:
                        if pattern in result.stdout.lower():
                            threats.append(MalwareThreat(
                                id=f"REG-{key}-{int(time.time())}",
                                name="Suspicious.Registry.Entry",
                                threat_type=ThreatType.TROJAN,
                                threat_level=ThreatLevel.HIGH,
                                file_path=None,
                                process_name=None,
                                description="Suspicious registry entry detected",
                                indicators=[f"Pattern: {pattern} in {key}"],
                                is_removable=True,
                                requires_restart=False,
                                hash=None
                            ))
                            break

        except:
            pass

        return threats

    def _check_scheduled_tasks(self) -> List[MalwareThreat]:
        """Check Windows scheduled tasks for malware"""
        threats = []

        try:
            result = subprocess.run(
                ["schtasks", "/query", "/fo", "LIST", "/v"],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0:
                # Check for suspicious tasks
                suspicious_patterns = [
                    "powershell -enc",
                    "cmd.exe /c",
                    "wscript",
                    "cscript",
                ]

                for pattern in suspicious_patterns:
                    if pattern in result.stdout.lower():
                        threats.append(MalwareThreat(
                            id=f"TASK-{int(time.time())}",
                            name="Suspicious.Scheduled.Task",
                            threat_type=ThreatType.TROJAN,
                            threat_level=ThreatLevel.HIGH,
                            file_path=None,
                            process_name=None,
                            description="Suspicious scheduled task detected",
                            indicators=[f"Pattern: {pattern}"],
                            is_removable=True,
                            requires_restart=False,
                            hash=None
                        ))
                        break

        except:
            pass

        return threats

    def _get_file_hash(self, file_path: str) -> Optional[str]:
        """Calculate file hash"""
        try:
            hasher = hashlib.sha256()
            with open(file_path, 'rb') as f:
                hasher.update(f.read())
            return hasher.hexdigest()
        except:
            return None

    def get_scan_report(self) -> Dict:
        """Generate comprehensive scan report"""
        severity_counts = {}
        type_counts = {}

        for threat in self.detected_threats:
            # Count by severity
            level = threat.threat_level.value
            severity_counts[level] = severity_counts.get(level, 0) + 1

            # Count by type
            t_type = threat.threat_type.value
            type_counts[t_type] = type_counts.get(t_type, 0) + 1

        return {
            "platform": self.platform,
            "total_threats": len(self.detected_threats),
            "by_severity": severity_counts,
            "by_type": type_counts,
            "threats": [
                {
                    "id": t.id,
                    "name": t.name,
                    "type": t.threat_type.value,
                    "severity": t.threat_level.value,
                    "file": t.file_path,
                    "process": t.process_name,
                    "description": t.description,
                    "indicators": t.indicators,
                    "removable": t.is_removable
                }
                for t in self.detected_threats
            ]
        }


# Example usage
if __name__ == "__main__":
    print("=" * 60)
    print("ðŸ¦  Malware Scanner - Benevolent Protocol")
    print("=" * 60)
    print()

    scanner = MalwareScanner()

    print(f"Platform: {scanner.platform.upper()}\n")

    # Quick scan
    threats = scanner.scan_system(quick_scan=True)

    print(f"\nðŸ“Š Scan Results:")
    print(f"   Total Threats: {len(threats)}\n")

    if threats:
        # Group by severity
        by_severity = {}
        for threat in threats:
            sev = threat.threat_level.value
            if sev not in by_severity:
                by_severity[sev] = []
            by_severity[sev].append(threat)

        # Display by severity (highest first)
        for severity in ["critical", "high", "medium", "low", "info"]:
            if severity in by_severity:
                print(f"{severity.upper()} ({len(by_severity[severity])}):")
                for threat in by_severity[severity]:
                    print(f"  â€¢ {threat.name}")
                    print(f"    Type: {threat.threat_type.value}")
                    print(f"    {threat.description}")
                    if threat.file_path:
                        print(f"    File: {threat.file_path}")
                    if threat.process_name:
                        print(f"    Process: {threat.process_name}")
                    print(f"    Indicators: {', '.join(threat.indicators)}")
                    print()
    else:
        print("   âœ… No threats detected\n")

    print("âœ… Malware scan complete")
